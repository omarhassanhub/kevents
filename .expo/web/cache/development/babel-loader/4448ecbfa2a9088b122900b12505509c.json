{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar TextExtraction = function () {\n  function TextExtraction(text, patterns) {\n    _classCallCheck(this, TextExtraction);\n\n    this.text = text;\n    this.patterns = patterns || [];\n  }\n\n  _createClass(TextExtraction, [{\n    key: \"parse\",\n    value: function parse() {\n      var _this = this;\n\n      var parsedTexts = [{\n        children: this.text\n      }];\n      this.patterns.forEach(function (pattern) {\n        var newParts = [];\n        parsedTexts.forEach(function (parsedText) {\n          if (parsedText._matched) {\n            newParts.push(parsedText);\n            return;\n          }\n\n          var parts = [];\n          var textLeft = parsedText.children;\n          var indexOfMatchedString = 0;\n\n          while (textLeft) {\n            var matches = pattern.pattern.exec(textLeft);\n\n            if (!matches) {\n              break;\n            }\n\n            var previousText = textLeft.substr(0, matches.index);\n            indexOfMatchedString += matches.index;\n            parts.push({\n              children: previousText\n            });\n            parts.push(_this.getMatchedPart(pattern, matches[0], matches, indexOfMatchedString));\n            textLeft = textLeft.substr(matches.index + matches[0].length);\n            indexOfMatchedString += matches[0].length;\n          }\n\n          parts.push({\n            children: textLeft\n          });\n          newParts.push.apply(newParts, parts);\n        });\n        parsedTexts = newParts;\n      });\n      parsedTexts.forEach(function (parsedText) {\n        return delete parsedText._matched;\n      });\n      return parsedTexts.filter(function (t) {\n        return !!t.children;\n      });\n    }\n  }, {\n    key: \"getMatchedPart\",\n    value: function getMatchedPart(matchedPattern, text, matches, index) {\n      var props = {};\n      Object.keys(matchedPattern).forEach(function (key) {\n        if (key === 'pattern' || key === 'renderText') {\n          return;\n        }\n\n        if (typeof matchedPattern[key] === 'function') {\n          props[key] = function () {\n            return matchedPattern[key](text, index);\n          };\n        } else {\n          props[key] = matchedPattern[key];\n        }\n      });\n      var children = text;\n\n      if (matchedPattern.renderText && typeof matchedPattern.renderText === 'function') {\n        children = matchedPattern.renderText(text, matches);\n      }\n\n      return _objectSpread({}, props, {\n        children: children,\n        _matched: true\n      });\n    }\n  }]);\n\n  return TextExtraction;\n}();\n\nexport default TextExtraction;","map":{"version":3,"sources":["/Users/hassao03/code/node_modules/react-native-parsed-text/src/lib/TextExtraction.js"],"names":["TextExtraction","text","patterns","parsedTexts","children","forEach","pattern","newParts","parsedText","_matched","push","parts","textLeft","indexOfMatchedString","matches","exec","previousText","substr","index","getMatchedPart","length","filter","t","matchedPattern","props","Object","keys","key","renderText"],"mappings":"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","sourcesContent":["class TextExtraction {\n  /**\n   * @param {String} text - Text to be parsed\n   * @param {Object[]} patterns - Patterns to be used when parsed\n   *                              other options than pattern would be added to the parsed content\n   * @param {RegExp} patterns[].pattern - RegExp to be used for parsing\n   */\n  constructor(text, patterns) {\n    this.text     = text;\n    this.patterns = patterns || [];\n  }\n\n  /**\n   * Returns parts of the text with their own props\n   * @return {Object[]} - props for all the parts of the text\n   */\n  parse() {\n    let parsedTexts = [{children: this.text}];\n    this.patterns.forEach((pattern) => {\n      let newParts = [];\n\n      parsedTexts.forEach((parsedText) => {\n        // Only allow for now one parsing\n        if (parsedText._matched) {\n          newParts.push(parsedText);\n\n          return;\n        }\n\n        let parts    = [];\n        let textLeft = parsedText.children;\n        let indexOfMatchedString = 0;\n\n        while (textLeft) {\n          let matches = pattern.pattern.exec(textLeft);\n\n          if (!matches) { break; }\n\n          let previousText = textLeft.substr(0, matches.index);\n          indexOfMatchedString += matches.index;\n\n          parts.push({children: previousText});\n\n          parts.push(this.getMatchedPart(pattern, matches[0], matches, indexOfMatchedString));\n\n          textLeft = textLeft.substr(matches.index + matches[0].length);\n          indexOfMatchedString += matches[0].length;\n        }\n\n        parts.push({children: textLeft});\n\n        newParts.push(...parts);\n      });\n\n      parsedTexts = newParts;\n    });\n\n    // Remove _matched key.\n    parsedTexts.forEach((parsedText) => delete(parsedText._matched));\n\n    return parsedTexts.filter(t => !!t.children);\n  }\n\n  // private\n\n  /**\n   * @param {Object} matchedPattern - pattern configuration of the pattern used to match the text\n   * @param {RegExp} matchedPattern.pattern - pattern used to match the text\n   * @param {String} text - Text matching the pattern\n   * @param {String[]} matches - Result of the RegExp.exec\n   * @param {Integer} index - Index of the matched string in the whole string\n   * @return {Object} props for the matched text\n   */\n  getMatchedPart(matchedPattern, text, matches, index) {\n    let props = {};\n\n    Object.keys(matchedPattern).forEach((key) => {\n      if (key === 'pattern' || key === 'renderText') { return; }\n\n      if (typeof matchedPattern[key] === 'function') {\n        props[key] = () => matchedPattern[key](text, index);\n      } else {\n        props[key] = matchedPattern[key];\n      }\n    });\n\n    let children = text;\n    if (matchedPattern.renderText && typeof matchedPattern.renderText === 'function') {\n      children = matchedPattern.renderText(text, matches);\n    }\n\n    return {\n      ...props,\n      children: children,\n      _matched: true,\n    };\n  }\n}\n\nexport default TextExtraction;\n"]},"metadata":{},"sourceType":"module"}